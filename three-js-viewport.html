
<polymer-element name="three-js-viewport" constructor="threeJsViewport" attributes="name cameraId composerId left bottom width height postProcess"
touch-action="none"  on-mousemove="{{onPointerMove}}" on-down="{{onPointerDown}}" on-up="{{onPointerUp}}" 
>
<!--on-track="{{onPointerMove}}" on-down="{{onPointerDown}}" on-up="{{onPointerUp}}"-->
  <script>
    Polymer('three-js-viewport', {
      object: null,
      name: "",
      updatable:true,
      cameraId:null,
      camera:null,
      controls:null,
      composerId:null,
      composer:null,
      
      postProcess:false,
      
      left: 0,
			bottom: 0,
			width: 0.5,
			height: 1.0,
			background: new THREE.Color(),//.setRGB( 0.8, 0.5, 0.7 ),
			//base callbacks
      enteredView:function(){
        console.log("in threejsviewport");
        this._setStyle();
        var camera   = this.parentNode.querySelector(this.cameraId);
        if(camera) this.camera = camera = camera.object;
        
        var composer = this.parentNode.querySelector(this.composerId);
        if(composer) this.composer = composer = composer.composer;
        
        this.selectionHelper = new SelectionHelper({camera:this.camera})
        //TODO: move this?
        this.selectionHelper.viewWidth = this.realWidth;
        this.selectionHelper.viewHeight = this.realHeight;
        
        this.addToParent3();
      },
      //event handlers
      onPointerMove:function(event)
      {
        //if(!this.selectionHelper) return;
        //console.log("foo",this.name);
        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;
        
        var activeScenes = this.activeScenes;
        
        for(var key in activeScenes)
        {
          var activeScene = activeScenes[key];
          if(!(activeScene._pickable)) continue;
          this.selectionHelper.hiearchyRoot = activeScene.children;
          this.parentNode.highlightedObject = this.selectionHelper.getObjectAt(x,y,this.camera.inOrthographicMode);
          if( this.parentNode.highlightedObject) break;
        }
        this._noMove = false;
      },
      onPointerDown:function(event)
      {
        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._noMove = true;
        this._actionInProgress = true;
        this._pushStart = new Date().getTime();

			  //set focus so keyboard binding works
			  /*if( document.activeElement != this.impl)
			  {
				  this.impl.focus();
        }*/
      },
      onPointerUp:function(event)
      {
        var activeScenes = this.activeScenes;

        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._actionInProgress = false;
        var _pushEnd = new Date().getTime()
        var _elapsed = _pushEnd - this._pushStart;
        this._longAction = !(_elapsed <= 125);
        this._longStaticTap = (_elapsed >= 300 && this._noMove == true);

        var selected = null;
        for(var key in activeScenes)
        {
          var activeScene = activeScenes[key];
          if(!(activeScene._pickable)) continue;
          this.selectionHelper.hiearchyRoot = activeScene.children;
          selected = this.selectionHelper.getObjectAt(x,y,this.camera.inOrthographicMode);
          if( selected) break;
        }

        console.log("selected", selected,x,y);

        if(this._longStaticTap)
        {
          this.fire("longstatictap",{position:{x:x,y:y}});
        }
        else if( selected != null && selected != undefined)
        {
          //this.selectionHelper.selectObjectAt(x,y)
          //multi select handling
          if(!(this.parentNode.shiftPress))
          {
            //no shift pressed: single selection
            //this.selectedObjects=.length = 0;
            //this.selectedObjects.push(selected);
            this.parentNode.selectedObjects=[selected];
          }
          else
          {
            var tmpArray = [];
            tmpArray = this.parentNode.selectedObjects.slice(0);
            //necessary hack to work with polymer change handlers
            
             var index = tmpArray.indexOf(selected);
             if(index>-1) //already present, remove selection
             {
              tmpArray.splice(index,1);
             }
             else//not yet present, add selection
             {
              tmpArray.push( selected );
             }
             this.parentNode.selectedObjects = tmpArray;
          }
        }
        else
        {
          if (this._longAction == false)
          {
				    this.selectionHelper._unSelect();
            //multiselect
            this.parentNode.selectedObjects=[];
          }
          else
          {
            this.fire("longmovetap",{position:{x:x,y:y}});
          }
        }
      },
      
      //api
      update:function()
      {
        if(this.controls) this.controls.update();
        
        
      },
      render:function(renderer, activeScenes, width, height)
      {
        var left   = Math.floor( width  * this.left );
				var bottom = Math.floor( height * this.bottom );
			  var width  = Math.floor( width  * this.width );
				var height = Math.floor( height * this.height );
				
				this.activeScenes = activeScenes;

        if(this.postProcess && this.composer && renderer instanceof THREE.WebGLRenderer)
        {
            renderer.setViewport( left, bottom, width, height );
            //FIXME: hack !
            if(this.composer.camera != this.camera)
            {
              this.composer.altInit(renderer, activeScenes, this.camera);
              console.log("this.width, this.height",width, height);
              this.composer.composer.setSize(width, height);
            }
            this.composer.render();
        }
        else
        {   
          try{
			      renderer.setViewport( left, bottom, width, height );
			      renderer.setScissor( left, bottom, width, height );
			      renderer.enableScissorTest ( true );
			      }catch(error){}
            renderer.setClearColor( this.background );

            var camera = this.camera;
			      camera.aspect = width / height;
			      camera.setSize(width,height);
			      camera.updateProjectionMatrix();
			      
			      for(var key in activeScenes)
            {
              var activeScene = activeScenes[key];
              activeScene.updateMatrixWorld();
              renderer.render(activeScene, camera);
            }
            try{
            renderer.enableScissorTest ( false );
            }catch(error){}
        }
      },
      add3:function(child){
      
        if( child instanceof threeJsControls )
        {
          var controls = child.object;
          console.log("adding controls to viewport");
          this.controls = controls;
          this.async(function()
          {
            child.init(this.camera, this);
          });
        }
        if(child instanceof threeJsFxComposer )
        {
          console.log("adding fx composer to viewport");
          this.composer = child;
        }
      },
			addToParent3: function() {
        if (this.parentNode.add3 && !this.objectParent) {
          this.objectParent = this.parentNode;
          this.parentNode.add3(this);
          var parentName = this.parentNode.localName;
          console.log('[%s]: request adding to [%s]', this.localName + (this.id ? '#' + this.id : ''), parentName);
        }
      },
      removeFromParent3: function() {
        if (this.objectParent) {
          this.objectParent.remove3(this);
          this.objectParent = null;
          console.log('[%s]: REMOVED from threejs-objectParent', this.localName + (this.id ? '#' + this.id : ''));
        }
      },
      //helpers
      _setStyle:function()
      {
	      //setup width & height
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));
	      this.left = parseInt(cs.getPropertyValue("left").replace("px",""));
	      //this.bottom = parseInt(cs.getPropertyValue("bottom").replace("px",""));
	      this.realWidth = this.width;
	      this.realHeight = this.height;
	      
	      this.width = this.width/this.parentNode.width;
	      this.height= this.height/this.parentNode.height;
	      this.left= this.left/this.parentNode.width;
	      console.log("width etc", this.width, this.height, this.left);
	       
	      
        //setup backround color
	      this.bg = cs.getPropertyValue("background-color");
	      //this._convertColor(this.bg);
		    //this.renderer.setClearColor( this.bg, 1 );	  
      },
    });
  </script>
</polymer-element>

