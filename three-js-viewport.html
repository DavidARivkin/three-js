
<polymer-element name="three-js-viewport" constructor="threeJsViewport" attributes="name cameraId composerId left bottom width height postProcess pickOnPointerMove"
touch-action="none"  on-mousemove="{{onPointerMove}}" on-down="{{onPointerDown}}" on-up="{{onPointerUp}}" 
>
  <script>
    Polymer('three-js-viewport', {
      object: null,
      name: "",
      
      /**
       * 'updatable` toggles the update loop of the viewport & its 
       * contents
       * 
       * @attribute updatable
       * @type bool
      */
      updatable:true,
      
      /**
       * 'cameraId` id of the camera to use if linking
       * to a camera outside the viewport
       * 
       * @attribute cameraId
       * @type bool
      */
      cameraId:null,
      camera:null,
      
      /**
       * 'controlsId` id of the controls to use if linking
       * to controls outside the viewport
       * 
       * @attribute controlsId
       * @type bool
      */
      controlsId:null,
      controls:null,
      
      /**
       * 'composerId` id of the fxComposer to use if linking
       * to an fxComposer outside the viewport
       * 
       * @attribute composerId
       * @type bool
      */
      composerId:null,
      composer:null,
      
      /**
       * 'postProcess` toggles the post processing (pixel shader based, so 
       * webgl only)
       * 
       * @attribute postProcess
       * @type bool
      */
      postProcess:false,//toggle post processing effects
      
      /**
       * 'pickOnPointerMove` toggle picking to be done when pointer moves
       * 
       * @attribute pickOnPointerMove
       * @type bool
      */
      pickOnPointerMove: false,
      
      left: 0,
			bottom: 0,
			width: 1.0,
			height: 1.0,
			background: new THREE.Color(),
			
			_pointerMoveTicks:0,
			
			//base callbacks
      attached:function(){
        //console.log("in threejsviewport");
        var camera   = this.parentNode.querySelector(this.cameraId);
        if(camera) this.camera = camera = camera.object;
        
        var controls   = this.parentNode.querySelector(this.controlsId);
        if(controls) this.controls = controls = controls.object;
        
        var composer = this.parentNode.querySelector(this.composerId);
        if(composer) this.composer = composer = composer.composer;
        
        this.selectionHelper = new SelectionHelper({camera:this.camera})

        this.addToParent3();
        this.onResize();
        
        //alternative picking EXPERIMENTAL
        this.mouse= {x:300,y:200};
        this.pickingTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
				this.pickingTexture.generateMipmaps = false;
				//octree EXPERIMENTAL
				this.octree = null; 
				
        //setup various handlers
        window.addEventListener("resize",this.onResize.bind(this));
      },
      
      pick:function(renderer,scene,camera) {
        var mouse = this.mouse;
        var pickingData = [];
				//render the picking scene off-screen
				var pickingTexture = this.pickingTexture;
				renderer.render( scene, camera, pickingTexture );
				var gl = renderer.getContext();
				//read the pixel under the mouse from the texture
				var pixelBuffer = new Uint8Array( 4 );
				gl.readPixels( mouse.x, pickingTexture.height - mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer );

				//interpret the pixel as an ID
				var id = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
				var data = pickingData[ id ];
				//console.log("id", id);
				if ( data)
				{
					//move our highlightBox so that it surrounds the picked object
          console.log("data", data);
			  }
			  renderer.clear();
			},
			
			pickOctree:function(event){
			          var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;
        
        var v = new THREE.Vector3((x / this.realWidth) * 2 - 1, -(y / this.realHeight) * 2 + 1, 1);
        x = (x / this.realWidth) * 2 - 1;
        y = -(y / this.realHeight) * 2 + 1, 1;
        var activeScenes = this.activeScenes;
        
        for(var key in activeScenes)
        {
          var activeScene = activeScenes[key];
          var camera = this.camera;
          var octree = this.octree;
          
          var s = Date.now();
          var projector = new THREE.Projector();
          var vector = new THREE.Vector3( x, y, 1 );
			    projector.unprojectVector( v, camera );

			    var raycaster = new THREE.Raycaster( camera.position, v.sub( camera.position ).normalize() );
			    var octreeObjects;
			    var numObjects;
			    var numFaces = 0;
			    var intersections;
			    
          var radiusSearch = 10;
				  //octreeObjects = octree.search( raycaster.ray.origin, raycaster.ray.far, true, raycaster.ray.direction );
				  //meshesSearch = octree.search( rayCaster.ray.origin, radiusSearch, true, rayCaster.ray.direction );
				  //intersections = raycaster.intersectOctreeObjects( octreeObjects );
				  numObjects = octreeObjects.length;
				  //console.log("blah",octreeObjects);
				  var e = Date.now();
		  //console.log( "Time to pick (octree)" + (e-s) + " ms" );
          break;
        }
        return;
			},
      
      //attribute change handlers
      cameraChanged:function(oldCam,newCam){
        if(this.controls) this.controls.container.init(this.camera, this);
        this.selectionHelper.camera = this.camera;
      },
      //event handlers
      onResize:function(){
        this._setStyle();
        this.selectionHelper.viewWidth = this.realWidth;
        this.selectionHelper.viewHeight = this.realHeight;
      },
      onPointerMove:function(event)
      {
        //if(!this.selectionHelper) return;
        //console.log("foo",this.name);
        if(!(this.camera) || !(this.pickOnPointerMove) ) return;//TODO:this whole method should be disabled for as long as there is no camera
        
        this._pointerMoveTicks++;
        if(this._pointerMoveTicks <5)return;
        this._pointerMoveTicks=0;
        
        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;
        
        //FIXME:temporary hack
        this.mouse.x = x;
        this.mouse.y = y;
        
        var activeScenes = this.activeScenes;
        
        for(var key in activeScenes)
        {
          var activeScene = activeScenes[key];
          if(!(activeScene._pickable)) continue;
          this.selectionHelper.hiearchyRoot = activeScene.children;
          this.parentNode.highlightedObject = this.selectionHelper.getObjectAt(x,y,this.camera.inOrthographicMode);
          if( this.parentNode.highlightedObject) break;
          return;
        }
        this._noMove = false;
      },
      onPointerDown:function(event)
      {
        if(!(this.camera)) return;//TODO:this whole method should be disabled for as long as there is no camera
      
        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._noMove = true;
        this._actionInProgress = true;
        this._pushStart = new Date().getTime();
			  //set focus so keyboard binding works
			  /*if( document.activeElement != this.impl)
			  {
				  this.impl.focus();
        }*/
      },
      onPointerUp:function(event)
      {
        if(!(this.camera)) return;//TODO:this whole method should be disabled for as long as there is no camera
      
        var activeScenes = this.activeScenes;

        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        var selected = null;
        for(var key in activeScenes)
        {
          var activeScene = activeScenes[key];
          if(!(activeScene._pickable)) continue;
          this.selectionHelper.hiearchyRoot = activeScene.children;
          
          selected = this.selectionHelper.getObjectAt(x,y,this.camera.inOrthographicMode);
          
          if( selected){
            var selectionDetails = selected.userData.tmpIntersectData;
            delete selected.userData.tmpIntersectData
            this.fire("objectpicked",{pickingInfos:selectionDetails});
            break;
          }
        }
        this._actionInProgress = false;
        var _pushEnd = new Date().getTime()
        var _elapsed = _pushEnd - this._pushStart;
        this._longAction = !(_elapsed <= 125);
        this._longStaticTap = (_elapsed >= 300 && this._noMove == true);
        
        //console.log("selected", selected,x,y);

        if(this._longStaticTap)
        {
          this.fire("longstatictap",{position:{x:x,y:y}});
        }
        else if( selected != null && selected != undefined)
        {
          //this.selectionHelper.selectObjectAt(x,y)
          //multi select handling
          if(!(this.parentNode.shiftPress))
          {
            //no shift pressed: single selection
            //this.selectedObjects.push(selected);
            this.parentNode.selectedObjects=[selected];
          }
          else
          {
            var tmpArray = [];
            tmpArray = this.parentNode.selectedObjects.slice(0);
            //necessary hack to work with polymer change handlers
             var index = tmpArray.indexOf(selected);
             if(index>-1) //already present, remove selection
             {
              tmpArray.splice(index,1);
             }
             else//not yet present, add selection
             {
              tmpArray.push( selected );
             }
             this.parentNode.selectedObjects = tmpArray;
          }
        }
        else
        {
          if (this._longAction == false)
          {
				    this.selectionHelper._unSelect();
            //multiselect
            this.parentNode.selectedObjects=[];
          }
          else
          {
            this.fire("longmovetap",{position:{x:x,y:y}});
          }
        }
      },
      //api
      update:function()
      {
        if(this.controls) this.controls.update();
        if(this.octree) this.octree.update();
      },
      render:function(renderer, activeScenes, renderables, width, height)
      {
        var left   = Math.floor( width  * this.left );
				var bottom = Math.floor( height * this.bottom );
			  var width  = Math.floor( width  * this.width );
				var height = Math.floor( height * this.height );

				this.activeScenes = activeScenes;
				
				//FIXME god awfull hack, only used for three-stats
				for(var i=0;i<renderables.length;i++)
        {
				  if(!('scene' in renderables[i])){
				    renderables[i].render();
				  }
				}

        if(this.postProcess && this.composer && renderer instanceof THREE.WebGLRenderer)
        {
            renderer.setViewport( left, bottom, width, height );
            //FIXME: hack !
            if(this.composer.camera != this.camera)
            {
              this.composer.altInit(renderer, activeScenes, this.camera);
              this.composer.composer.setSize(width, height);
            }
            this.composer.render();
        }
        else
        {   
          try{
			      renderer.setViewport( left, bottom, width, height );
			      renderer.setScissor( left, bottom, width, height );
			      renderer.enableScissorTest ( true );
			      }catch(error){}
            renderer.setClearColor( this.background );

            var camera = this.camera;
            if(camera){
			        camera.aspect = width / height;
			        camera.setSize(width,height);
			        camera.updateProjectionMatrix();
			     
			        for(var key in activeScenes)
              {
                var activeScene = activeScenes[key];
                activeScene.updateMatrixWorld();
                //this.pick(renderer, activeScene, camera);
                
                for(var i=0;i<renderables.length;i++)
                {
                  if('scene' in renderables[i]){
                    if(renderables[i].scene == activeScene)
                    {
                    renderables[i].renderer = renderer;
                    renderables[i].camera   = camera;
                    renderables[i].render(  );
                    }
                  }
                  
                }
                renderer.render(activeScene, camera);

                /*
                FIXME:experimental , remove
               if(!(this.octree)){
                this.octree = new THREE.Octree( {
					        // when undeferred = true, objects are inserted immediately
					        // instead of being deferred until next octree.update() call
					        // this may decrease performance as it forces a matrix update
					        undeferred: true,
					        // set the max depth of tree
					        depthMax: Infinity,
					        // max number of objects before nodes split or merge
					        objectsThreshold: 8,
					        // percent between 0 and 1 that nodes will overlap each other
					        // helps insert objects that lie over more than one node
					        overlapPct: 0.15,
					        // pass the scene to visualize the octree
					        scene: activeScene
				        } );
				        var octree = this.octree;
                activeScene.addEventListener("objectAdded",function(event){
                  console.log("added to scene",event);
                  var mesh = event.object;
                  //octree.add( mesh, { useFaces: true } );
                });
              }*/
              }
            }
            try{
            renderer.enableScissorTest ( false );
            }catch(error){}
        }
      },
      add3:function(child){
        if( child instanceof threeJsControls )
        {
          var controls = child.object;
          this.controls = controls;
          child.object.container = child;
          /*if(!this.camera) return;
          this.async(function()
          {
            child.init(this.camera, this);
          });*/
        }
        if( child instanceof threeJsCamera )
        {
          var camera = child.object;
          this.camera = camera;
        }
        if(child instanceof threeJsFxComposer )
        {
          this.composer = child;
        }
      },
      remove3: function(child) {
        //TODO: do we actually need to do anything to clean up ??
      },
			addToParent3: function() {
        if (this.parentNode.add3 && !this.objectParent) {
          this.objectParent = this.parentNode;
          this.parentNode.add3(this);
          var parentName = this.parentNode.localName;
          //console.log('[%s]: request adding to [%s]', this.localName + (this.id ? '#' + this.id : ''), parentName);
        }
      },
      removeFromParent3: function() {
        if (this.objectParent) {
          this.objectParent.remove3(this);
          this.objectParent = null;
          //console.log('[%s]: REMOVED from threejs-objectParent', this.localName + (this.id ? '#' + this.id : ''));
        }
      },
      //helpers
      _setStyle:function()
      {
	      //setup width & height
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));
	      this.left = parseInt(cs.getPropertyValue("left").replace("px",""));
	      this.bottom = parseInt(cs.getPropertyValue("bottom").replace("px","")) || 0;
	      this.realWidth = this.width;
	      this.realHeight = this.height;
	      
	      this.width = this.width/this.parentNode.width;
	      this.height= this.height/this.parentNode.height;
	      this.left= this.left/this.parentNode.width;
	      //console.log("width etc", this.width, this.height, this.left);
	       
	      //THREE.Color.//.setRGB( 0.8, 0.5, 0.7 ),
        //setup backround color
	      this.bg = cs.getPropertyValue("background-color");
	      //this._convertColor(this.bg);
		    //this.renderer.setClearColor( this.bg, 1 );	  
      },
    });
  </script>
</polymer-element>

