<script src="lib/Detector.js"></script>
<script src="lib/three.js"></script>
<script src="lib/helpers/screen-capture.js"></script>
<script src="lib/helpers/selection-helper.js"></script>
<script src="lib/helpers/normalizeEvent.js"></script>

<link rel="import" href="components/polymer/polymer.html">
<link rel="import" href="three-js-baseElements.html">
<link rel="import" href="three-js-scene.html">
<link rel="import" href="three-js-lights.html">
<link rel="import" href="three-js-cameras.html">
<link rel="import" href="three-js-controls.html">
<link rel="import" href="three-helpers.html">
<link rel="import" href="three-postfx.html">
<link rel="import" href="three-stats.html">

<!--Essentials:
- view data : width & height

-renderer
-scene
-camera
-controls

renderer needs:
-view data
-scene
-camera

scene needs:

camera needs:
-view data

controls needs:
- camera
- renderer
-->

<polymer-element name="three-js" attributes="renderNow fullScreen postProcess selectedObjects highlightedObject"
on-three-js-get-renderer="{{getRenderer}}" on-three-js-get-scene="{{getScene}}" on-three-js-get-camera="{{getCamera}}" 
touch-action="none" on-track="{{onPointerMove}}" on-down="{{onPointerDown}}" on-up="{{onPointerUp}}" 
on-keyup="{{onKeyUp}}" on-keydown="{{onKeyDown}}" on-keypress="{{onKeyPress}}" tabindex="0"
>
<template>
  <link rel="stylesheet" type="text/css" href="three-js.css">
    <content select="three-js-scene" id="scene-inner"> </content>
    <content select="drag-drop" id="dragDropLayer"> </content> 
    <content select="three-stats" ></content>
  </template>
  <script>
    Polymer('three-js', {
      renderNow: false,
      fullScreen: false,
      postProcess: false,
      
      scenes:null,
      activeScenes:null,
      
      selectedObjects: null,
      highlightedObject: null,
      
      keys:[],
      
      _animationId:null,
      //generic custom element callbacks
      created: function() {
        this.width = 0;
        this.height = 0;
        this.bg = "rgb(255, 255, 255)";
        
        this.scenes = {};
        this.activeScenes = {};
        this.updatables = [];//storage for all items that need to be synch with the update method
        this.selectedObjects = [];
      },
      ready: function() {
        this._setupRenderer();
      },
      enteredView:function()
      {
        //setup various handlers
        window.addEventListener("resize",this.onResize.bind(this));
        if (this.requestFullscreen) document.addEventListener("fullscreenchange", this.onFullScreenChange.bind(this), false);
        if (this.mozRequestFullScreen) document.addEventListener("mozfullscreenchange", this.onFullScreenChange.bind(this), false);
        if (this.webkitRequestFullScreen) document.addEventListener("webkitfullscreenchange", this.onFullScreenChange.bind(this), false);
        
        this._setStyle();
        this._setupHelpers();
        this.animate();
        this.onResize();
      },
      //initialization methods
      _setupRenderer: function()
      {
        if ( Detector.webgl )
        {var renderer = new THREE.WebGLRenderer( {antialias:true, preserveDrawingBuffer:true} );}
		    else
        { var renderer = new THREE.CanvasRenderer(); }
		    renderer.setSize(this.offsetWidth, this.offsetHeight);

		    renderer.shadowMapEnabled = true;//this.showShadows;
		    renderer.shadowMapAutoUpdate = true; //this.showShadows;
		    renderer.shadowMapSoft = true;
		    renderer.shadowMapType = THREE.PCFShadowMap; // options are THREE.BasicShadowMap | THREE.PCFShadowMap | THREE.PCFSoftShadowMap
		    renderer.autoClear = false;
	      renderer.autoUpdateScene = false;
	      this._convertColor(this.bg);
		    renderer.setClearColor( this.bg, 1 );	

        //if lightdom this.appendChild(renderer.domElement);
        this.shadowRoot.appendChild(renderer.domElement);
        this.renderer = renderer;
        
        ///
        //necessary hack for effectomposer
        THREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
        THREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
        THREE.EffectComposer.scene = new THREE.Scene();
        THREE.EffectComposer.scene.add( THREE.EffectComposer.quad );
        
        var self = this;
        if ( Detector.webgl ){
        renderer.context.canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
            console.log("webgl context lost");
            self.removeEventListener("webglcontextlost");
            cancelAnimationFrame(this._animationId); 
            
            function resetToInitialState(ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                  ctx.disableVertexAttribArray(ii);
                  ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                  ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);

                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                  ctx.activeTexture(ctx.TEXTURE0 + ii);
                  ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                  ctx.bindTexture(ctx.TEXTURE_2D, null);
                }

                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                // TODO: Delete this IF.
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                  ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

                // TODO: This should NOT be needed but Firefox fails with 'hint'
                while(ctx.getError());
              }
            //resetToInitialState(renderer.context);
            //self._setupRenderer();
        }, false);

        renderer.context.canvas.addEventListener("webglcontextrestored", function(event) {
           console.log("context restored");
        }, false);
        }
      },
      _setupHelpers: function()
      {
        //console.log("setup helpers");
        /*var activeScenes = this.querySelectorAll('three-js-scene[active]');
        for(var i = 0 ;i< activeScenes.length;i++)
        {
          var scene = activeScenes[i];
          
          this.activeScenes[ scene.name ] = scene.object;
          this.scenes[ activeScenes[i].name] = scene.object;
        }
        
        var activeScene = scene;
        if(activeScene)
        {
          this.hierarchyRoot = activeScene.querySelector('[hierarchyRoot]').object;
          this.selectionHelper = new SelectionHelper({camera:this.camera,color:0x000000,textColor:0xffffff})
		      this.selectionHelper.hiearchyRoot = activeScene.object.children;
          //TODO: move this?
          this.selectionHelper.viewWidth = this.width;
          this.selectionHelper.viewHeight = this.height;
        }*/
        
      },
      //event handlers
      onResize: function()
      {
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));

        //resize all that is needed
        //BUG in firefox: dpr is not 1 on desktop, scaling issue ensue, so forcing to "1"
        this.dpr=1;
		    this.resUpscaler = 1;
        this.hRes = this.width * this.dpr * this.resUpscaler;
        this.vRes = this.height * this.dpr * this.resUpscaler;
        
        if(this.camera)
        {
		      this.camera.aspect = this.width / this.height;
          this.camera.setSize(this.width,this.height);
		      this.camera.updateProjectionMatrix();
        }
        
		    this.renderer.setSize( this.width,this.height );
        if(this.renderer instanceof THREE.WebGLRenderer && this.postProcess == true && this.finalComposer)
        {
          this.finalComposer.setSize(this.hRes, this.vRes);
        }

        if(this.selectionHelper)
        {
          this.selectionHelper.viewWidth = this.width;
          this.selectionHelper.viewHeight = this.height;
        }
      },
      onFullScreenChange:function()
      {
        //workaround to reset this.fullScreen to correct value when pressing exit etc in full screen mode
        this.fullScreen = !(!document.fullscreenElement &&    // alternative standard method
        !document.mozFullScreenElement && !document.webkitFullscreenElement);
      },
      onKeyPress:function(event)
      {
        //console.log("key pressed")
      },
      onKeyDown:function(event)
	    {//overidable method stand in
        this.keys[event.keyCode] = true;
        this.shiftPress = event.shiftKey;
        //console.log("key down")
	    },
      onKeyUp:function(event)
	    {//overidable method stand in
        this.keys[event.keyCode] = false;
        this.shiftPress = event.shiftKey;
	    },
      onPointerMove:function(event)
      {
        if(!this.selectionHelper) return;

        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this.highlightedObject = this.selectionHelper.getObjectAt(x,y);

        this._noMove = false;
      },
      onPointerDown:function(event)
      {
        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._noMove = true;
        this._actionInProgress = true;
        this._pushStart = new Date().getTime();

			  //set focus so keyboard binding works
			  if( document.activeElement != this.impl)
			  {
				  this.impl.focus();
        }
      },
      onPointerUp:function(event)
      {
        if(!this.selectionHelper) return;

        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._actionInProgress = false;
          var _pushEnd = new Date().getTime()
          var _elapsed = _pushEnd - this._pushStart;
          this._longAction = !(_elapsed <= 125);
          this._longStaticTap = (_elapsed >= 300 && this._noMove == true);

          var selected = this.selectionHelper.getObjectAt(x,y);

          if(this._longStaticTap)
          {
            this.fire("longstatictap",{position:{x:x,y:y}});
          }
          else if( selected != null && selected != undefined)
          {
            this.selectionHelper.selectObjectAt(x,y)
            //multi select handling
            if(!(this.shiftPress))
            {
              //no shift pressed: single selection
              //this.selectedObjects=.length = 0;
              //this.selectedObjects.push(selected);
              this.selectedObjects=[selected];
            }
            else
            {
              var tmpArray = [];
              tmpArray = this.selectedObjects.slice(0);
              //necessary hack to work with polymer change handlers
              
               var index = tmpArray.indexOf(selected);
               if(index>-1) //already present, remove selection
               {
                tmpArray.splice(index,1);
               }
               else//not yet present, add selection
               {
                tmpArray.push( selected );
               }
               this.selectedObjects = tmpArray;
            }
          }
          else
          {
            if (this._longAction == false)
            {
					    this.selectionHelper._unSelect();

              //multiselect
              this.selectedObjects=[];//.length=0;//=[];
            }
            else
            {
              this.fire("longmovetap",{position:{x:x,y:y}});
            }
          }
      },
      //public api
      getScene:function( name )
      {
        if(!(name)) {console.log("no scene name given"); return;}
        return this.scenes[name];
      },
      toggleScene:function( name )
      {
        if(!(name)) {console.log("no scene name given to toggle"); return;}
        var scene = this.scenes[name];
        //if(scene) this.scene = scene; this._setupHelpers(); this.scene.add( this.camera);
      },
      clearScene:function(sceneName)
      {
        var scene = this.scenes[sceneName];
        if(!(scene)) return;
        
        /*while (this.hierarchyRoot.children.length > 0) {
          this.hierarchyRoot.remove(this.hierarchyRoot.children[this.hierarchyRoot.children.length - 1]);
        }*/
        // cleanup without calling render (data needs to be cleaned up before a new scene can be generated)
        //see here https://github.com/mrdoob/three.js/issues/2760
        if(this.renderer instanceof THREE.WebGLRenderer)
        {
          this.renderer.initWebGLObjects(scene);
        }
      },
	    addToScene: function ( object, sceneName )
	    {
	      //if no scene name is given take the first one
	      if(!(sceneName)) for (var sceneName in this.scenes) if (this.scenes.hasOwnProperty(sceneName)) break;
	      
	      var scene = this.scenes[sceneName];
        if(!(scene)) {console.log("no valid scene found"); return;};

		    try
		    { 
			    scene.add( object );
		    }
		    catch(error)
		    {
			    console.log("Failed to add object",object, "to scene: error", error.message)
		    }
	    },
      removeFromScene : function( object, sceneName )
      {
        if(!(sceneName)) for (var sceneName in this.scenes) if (this.scenes.hasOwnProperty(sceneName)) break;
	      var scene = this.scenes[sceneName];
        if(!(scene)) {console.log("no valid scene found"); return;};
        
        try
		    {
			    scene.remove( object );
		    }
		    catch(error)
		    {
			    console.log("Failed to remove object from scene: error", error)
		    }
      },
	    captureScreen:function(callback, width, height)
	    {
		    var width = width || 640;
		    var height = height || 480;
		    if(callback === undefined)
		    {
			    throw new Error("no callback provided");
		    }
		    captureScreen(callback, this.renderer.domElement, width, height);
	    },
      add3: function(child) {
        if(child.updatable)
        {
          this.updatables.push( child );
        }
        if( child instanceof( threeJsScene ) ){
           console.log("lkmk");
           var scene = child.object;
           var active = child.attributes.getNamedItem("active");
           
           this.scenes[ scene.name ] = scene;
           if(active) this.activeScenes[ scene.name ] = scene;
           //this._injectScene( sceneNode )

           /*var scene = activeScenes[i];
           this.activeScenes[ scene.name ] = scene.object;
           this.scenes[ activeScenes[i].name] = scene.object;*/

           //if(this.scene && this.camera) this._setupHelpers();
        }
        if( child instanceof threeJsCamera ) {
          var camera = child.object;
          this._injectCamera(camera);
          //if(this.scene && this.camera) this._setupHelpers();
        }

        if( child instanceof threeJsControls )
        {
          var controls = child.object;
          this.async(function()
          {
            child.init(this.camera, this.renderer);
            this._injectControls(controls);
          });
        }
        if( child instanceof threeJsFxComposer)
        {
          this.finalComposer = child.composer;
          this.finalComposer.setSize(this.width, this.height);
        }
      },
      remove3: function(child) {
        //this.scene.remove(child.object);
        this.invalidate();
      },
      getRenderer: function(event) {
        event.detail.renderer = this.renderer;
        return this.renderer;
      },
      getScene: function(event) {
        event.detail.scene = this.scene;
        event.detail.activeScenes = this.activeScenes;
        return this.activeScenes;
      },
      getCamera: function(event) {
        event.detail.camera = this.camera;
        return this.camera;
      },
      
      //attribute change handlers / various handlers
      renderNowChanged: function() {
        this.render();
      },
      fullScreenChanged:function()
      {
        if(this.fullScreen)
        {
          if(this.requestFullScreen)this.requestFullScreen();
          if(this.webkitRequestFullScreen)this.webkitRequestFullScreen();
          if(this.mozRequestFullScreen)this.mozRequestFullScreen();
        }
        else
        {
          if(document.cancelFullScreen) document.cancelFullScreen();
          if(document.webkitCancelFullScreen) document.webkitCancelFullScreen();
          if(document.mozCancelFullScreen) document.mozCancelFullScreen();
        }
      },
      highlightedObjectChanged:function(oldHighlight)
      {
        //console.log("highlighted object changed",this.highlightedObject);
      },
      selectedObjectChanged:function(oldSelection)
      {
         //console.log("SELECTED object changed",this.selectedObject);
      },
      selectedObjectsChanged:function(oldSelections, newSelections)
      {
        function diff(a,b)
        {
          var a = a || [];
          var b = b || [];
          return a.filter(function(x) { return b.indexOf(x) < 0; })
        }
        var added = diff( newSelections, oldSelections);
        var removed = diff( oldSelections, newSelections);
        
        if(added.length>0) this.asyncFire("selectionsAdded",added);
        if(removed.length>0) this.asyncFire("selectionsRemoved",removed);
      },
      invalidate: function() {
        this.validateJob = this.job(this.validateJob, this.validate, 250);
      },
      validate: function() {
        (this.validateJob || this.nullJob).stop();

        if(this.controls) this.controls.update();
        this.render();
      },
      nullJob: {
        stop: function(){}
      },
      //other
      render: function() {
        if (! this.camera) {return;}
        
        if (this.renderer instanceof THREE.WebGLRenderer && this.postProcess == true && this.finalComposer)
        {
          //FIXME:hack
          //console.log("this.finalComposer",this.finalComposer.subComposers);
          if(this.finalComposer.subComposers)
          {
            for(var i=0;i<this.finalComposer.subComposers.length;i++)
            {
              this.finalComposer.subComposers[i].render();
            }
          }
          //hack
          if(this.finalComposer.subComposers && this.finalComposer.subComposers.length>0)
          {
            //console.log("rendering",this.finalComposer.subComposers);
            var normal  = this.finalComposer.subComposers[0].renderTarget2;
            var depth   = this.finalComposer.subComposers[1].renderTarget2;
            
            var lastPass = this.finalComposer.passes[this.finalComposer.passes.length-2];
            lastPass.uniforms[ 'tNormal' ].value  = normal;
            lastPass.uniforms[ 'tDepth' ].value   = depth;
          }
          //var lastPass = this.finalComposer.passes[this.finalComposer.passes.length-1];
          //lastPass.renderToScreen = true;
          this.renderer.clear();
          //this.finalComposer.reset();
          //HACK!
          for(var key in this.activeScenes)
          {
            var activeScene = this.activeScenes[key];
            //activeScene.updateMatrixWorld();
            //this.renderer.render(activeScene, this.camera);
            activeScene.traverse( function ( child ) { if(child.material)child.material.depthTest = false; } )
          }
          this.finalComposer.render();
        }
        else
        {
          this.renderer.clear();
          for(var key in this.activeScenes)
          {
            var activeScene = this.activeScenes[key];
            activeScene.updateMatrixWorld();
            this.renderer.render(activeScene, this.camera);
          }
        }
      },
      animate: function() 
      {
	      this.render();		
	      this.update();
	      this._animationId = requestAnimationFrame(this.animate.bind(this))
      },
      update: function()
      {
	        if(this.controls) this.controls.update();
          for(var i=0;i<this.updatables.length;i++)//any external items needing the same "heartbeat" can register "updatables"
          {
            try{
              if(this.updatables[i].update)
              {
                this.updatables[i].update();
              }
              else{
                this.updatables[i]();
              }
            }catch(error){};
          }
      },
      //helpers: TODO: move some of these to seperate js file
	    _convertColor: function(hex)
	    {
        hex = new THREE.Color().setStyle(hex);
        this.bg = hex;
	    },
      _injectScene: function(scene, active){
        this.scenes[scene.name] = scene;
        /*if(active && scene !== this.scene)
        {
          if(this.scene) scene.children = this.scene.children;
          this.scene = scene;
        }
        if(this.scene && this.camera)
        {
          this.fire("sceneready", {scene:this.scene,camera:this.camera});
        }*/
      },
      _injectCamera: function(camera){
        this.camera = camera;
        this.camera.aspect = this.width / this.height;
        this.camera.setSize(this.width,this.height);
		    this.camera.updateProjectionMatrix();
      },
      _injectControls: function(controls){
        this.controls = controls;
        console.log("controls are active",controls)
      },
      _setStyle:function()
      {
	      //setup width & height
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));
        //setup backround color
	      this.bg = cs.getPropertyValue("background-color");
	      this._convertColor(this.bg);
		    this.renderer.setClearColor( this.bg, 1 );	  
      },
    });
  </script>
</polymer-element>

