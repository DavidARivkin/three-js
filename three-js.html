<script src="lib/three.js"></script>
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="three-js-baseElements.html">
<link rel="import" href="three-js-cameras.html">


<polymer-element name="three-js" on-three-js-get-renderer="{{getRenderer}}" on-track="{{track}}" attributes="renderNow">
<template>
    <style>
      :host {
        display: block;
        position: relative;
      }
      canvas {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }
    </style>
  </template>
  <script>
    Polymer('three-js', {
      renderNow: false,
      fullScreen: false,

      //generic custom element callbacks
      created: function() {
        this.width = 0;
        this.height = 0;
        this.bg = "rgb(255, 255, 255)";

        //this.scene = new THREE.Scene();
        this.rootAssembly = new THREE.Object3D();
      },
      ready: function() {
        console.log("wrapper ready")
        var renderer = new THREE.WebGLRenderer({antialias: true});
        this.shadowRoot.appendChild(renderer.domElement);
        this.renderer = renderer;
        renderer.setSize(this.offsetWidth, this.offsetHeight);
        renderer.shadowMapEnabled = true;
        renderer.shadowMapType = THREE.PCFShadowMap;
        this.invalidate();
  
        //FIXME: workaround for bad child element insertion order
        if(this._tmpBuff)
        {
          for(var i=0;i<this._tmpBuff.length;i++)
          {
            console.log("bla",this._tmpBuff[i].localName)
            this.add3(this._tmpBuff[i]);
          }
        }  
      },
      enteredView:function()
      {
         console.log("entered view");
         this._setStyle();

         this.camera.aspect = this.width / this.height;
         this.camera.setSize(this.width,this.height);
		     this.camera.updateProjectionMatrix();
		     this.renderer.setSize( this.width,this.height );

        console.log("this.scene",this.scene)
      },

      renderNowChanged: function() {
        this.render();
      },
      invalidate: function() {
        this.validateJob = this.job(this.validateJob, this.validate, 250);
      },
      validate: function() {
        (this.validateJob || this.nullJob).stop();
        this.render();
      },
      nullJob: {
        stop: function(){}
      },
      render: function() {
        if (this.camera) {
          this.renderer.render(this.scene, this.camera);
        } else console.log('no camera');
      },
      add3: function(child) {
        //console.log("child", child.localName)
        //TODO: do this MUCH better
        if( child.localName === 'three-js-scene')
        {
          console.log("I want to add a scene");

          if(this.scene) child.object.children = this.scene.children;
          this.scene = child.object;
          console.log("this.scene added",this.scene)
        }


        if (child.localName === 'three-js-camera' || child.localName === 'three-js-combinedcamera' ) {
          this.camera = child.object;
          console.log("ADDED CAM");
        }
        if(!this.scene)
        {
          if(!this._tmpBuff) this._tmpBuff = [];
          this._tmpBuff.push(child);
        }
        else
        {
          if(child.object && child.localName !== 'three-js-scene' )
          {this.scene.add(child.object);}
          else
          {
            this.scene.add(child);
          }
        }
        this.invalidate();
      },
      remove3: function(child) {
        this.scene.remove(child.object);
        this.invalidate();
      },
      getRenderer: function(event) {
        event.detail.renderer = this.renderer;
        console.log("here")
        //return this.renderer;
      },
      //
      track: function(event) {
        var obj = this.camera;
        var obj = this.querySelector('[tracking]').object;
        //console.log("tracking",obj)
        if (obj) {
          // TODO(sjmiles): accumulating derivatives is numerically unstable
          // integrating samples over a single track sequence is a better practice
          // make this easier to do properly
          obj.position.x += event.ddx;
          obj.position.z += event.ddy;
          this.render();
        }
      },
      _setStyle:function()
      {
	      //setup width & height
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));
        //setup backround color
	      this.bg = cs.getPropertyValue("background-color");
      },
    });
  </script>
</polymer-element>




