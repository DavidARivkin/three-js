<script src="lib/Detector.js"></script>
<script src="lib/three.min.js"></script>
<script src="lib/helpers/screen-capture.js"></script>
<script src="lib/helpers/selection-helper.js"></script>
<script src="lib/helpers/normalizeEvent.js"></script>


<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="three-js-baseElements.html">
<link rel="import" href="three-js-cameras.html">
<link rel="import" href="three-js-controls.html">
<link rel="import" href="three-helpers.html">
<link rel="import" href="three-postfx.html">
<link rel="import" href="three-stats.html">


<!--Essentials:
- view data : width & height

-renderer
-scene
-camera
-controls

renderer needs:
-view data
-scene
-camera

scene needs:

camera needs:
-view data

controls needs:
- camera
- renderer



-->

<polymer-element name="three-js" attributes="renderNow fullScreen postProcess"
on-three-js-get-renderer="{{getRenderer}}" on-three-js-get-scene="{{getScene}}" on-three-js-get-camera="{{getCamera}}" 
on-track="{{track}}"
touch-action="none" on-pointermove="{{onPointerMove}}" on-pointerdown="{{onPointerDown}}" on-pointerup="{{onPointerUp}}" 
>
<template>
    <style>
      :host {
        display: block;
        position: relative;

         /*make things unselectable, cross browser*/
		      -webkit-touch-callout: none;
		      -webkit-user-select: none;
		      -khtml-user-select: none;
		      -moz-user-select: none;
		      -ms-user-select: none;
		      user-select: none;

        * {
		      opacity: 1;
          transition: opacity 300ms;
          position: absolute;
		      overflow:hidden;
		      background-color:#fff;
		
		      /*make things unselectable, cross browser*/
		      -webkit-touch-callout: none;
		      -webkit-user-select: none;
		      -khtml-user-select: none;
		      -moz-user-select: none;
		      -ms-user-select: none;
		      user-select: none;
	      }


      }
      canvas {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index:0;

        cursor:default;
        /*make things unselectable, cross browser*/
		      -webkit-touch-callout: none;
		      -webkit-user-select: none;
		      -khtml-user-select: none;
		      -moz-user-select: none;
		      -ms-user-select: none;
		      user-select: none;
      }
    </style>

    <!--experimental
    <input type="range" value="{{hue}}" min="0" max="2" step="0.1" style="z-index:9999999;position: absolute; display:block">
    <input type="text" value="{{hue}}" style="z-index:9999999;position: absolute;top:30px; display:block">
    <content select="three-js-scene" id="scene-inner"> </content>
    <content select="three-effect-composer" id="effects"> </content> -->

  </template>
  <script>
    Polymer('three-js', {
      renderNow: false,
      fullScreen: false,
      postProcess: false,

      selectedObject : null,
      highlightedObject: null,

      hue:3.0,

      //generic custom element callbacks
      created: function() {
        this.width = 0;
        this.height = 0;
        this.bg = "rgb(255, 255, 255)";

        //this.scene = new THREE.Scene();
        //this.hierarchyRoot = new THREE.Object3D();
      },
      ready: function() {
        this.setupRenderer();

        //FIXME: workaround for bad child element insertion order
        if(this._tmpBuff)
        {
          for(var i=this._tmpBuff.length-1;i >= 0 ; i--)
          {
            var child = this._tmpBuff[i];
            var childObj = child.object;
            this._tmpBuff.splice(i, 1);
             if(child.object && child.localName !== 'three-js-scene' && child.localName !== 'three-js-orbitcontrols')
            {
              //console.log("in root: child", child.localName, "added to ", this.localName);
              this.scene.add(child.object);
            }
            else if(child.object && child.localName === 'three-js-orbitcontrols')
            {
              child.init(this.camera,this.renderer);
              this.controls = child.object;
              //this.controls.addEventListener("change",function(){console.log("controls changed")})
            }
            else
            {
              //console.log("in root: OTHER: child", child.localName, "added to ", this.localName);
            }
          }
        }  
        console.log("ready",this,"_elementPrepared",this._elementPrepared,"inserted", this.__inserted,"upgraded", this.__upgraded__);
      },
      enteredView:function()
      {
        //setup various handlers
        window.addEventListener("resize",this.onResize.bind(this));

        if (this.requestFullscreen) document.addEventListener("fullscreenchange", this.onFullScreenChange.bind(this), false);
        if (this.mozRequestFullScreen) document.addEventListener("mozfullscreenchange", this.onFullScreenChange.bind(this), false);
        if (this.webkitRequestFullScreen) document.addEventListener("webkitfullscreenchange", this.onFullScreenChange.bind(this), false);

        this._setStyle();
        this.setupHelpers();
        this.animate();
        this.onResize();

        console.log("entered",this,"_elementPrepared",this._elementPrepared,"inserted", this.__inserted,"upgraded", this.__upgraded__);
      },
      //initialization methods
      setupRenderer: function()
      {
        if ( Detector.webgl )
        {
				    var renderer = new THREE.WebGLRenderer( {antialias:true, preserveDrawingBuffer:true} );
        }
		    else
        {
				    var renderer = new THREE.CanvasRenderer(); 
        }
		    renderer.setSize(this.offsetWidth, this.offsetHeight);

		    renderer.shadowMapEnabled = this.showShadows;
		    renderer.shadowMapAutoUpdate = this.showShadows;
		    renderer.shadowMapSoft = true;
		    renderer.shadowMapType = THREE.PCFShadowMap; // options are THREE.BasicShadowMap | THREE.PCFShadowMap | THREE.PCFSoftShadowMap
        this.convertColor(this.bg);
		    renderer.setClearColor( this.bg, 1 );	  

        //if lightdom this.appendChild(renderer.domElement);
        this.shadowRoot.appendChild(renderer.domElement);
        this.renderer = renderer;
      },
      setupHelpers: function()
      {
        console.log("setup helpers");
        var activeScene = document.querySelectorAll('three-js-scene[active]')[0];
        if(activeScene)
        {
          this.hierarchyRoot = activeScene.querySelector('[hierarchyRoot]').object;
          console.log("gne");
          this.selectionHelper = new SelectionHelper({camera:this.camera,color:0x000000,textColor:0xffffff})
		      this.selectionHelper.hiearchyRoot = this.hierarchyRoot.children;

          //TODO: move this?
          this.selectionHelper.viewWidth = this.width;
          this.selectionHelper.viewHeight = this.height;
        }
      },
      //event handlers
      onResize: function()
      {
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));

        //resize all that is needed
        //BUG in firefox: dpr is not 1 on desktop, scaling issue ensue, so forcing to "1"
        this.dpr=1;
		    this.resUpscaler = 1;
        this.hRes = this.width * this.dpr * this.resUpscaler;
        this.vRes = this.height * this.dpr * this.resUpscaler;
        
        if(this.camera)
        {
		      this.camera.aspect = this.width / this.height;
          this.camera.setSize(this.width,this.height);
		      this.camera.updateProjectionMatrix();
        }
        
		    this.renderer.setSize( this.width,this.height );

        if(this.renderer instanceof THREE.WebGLRenderer && this.postProcess == true && this.finalComposer)
        {
          this.finalComposer.setSize(this.hRes, this.vRes);
        }

        if(this.selectionHelper)
        {
          this.selectionHelper.viewWidth = this.width;
          this.selectionHelper.viewHeight = this.height;
        }
      },
      onFullScreenChange:function()
      {
        //workaround to reset this.fullScreen to correct value when pressing exit etc in full screen mode
        this.fullScreen = !(!document.fullscreenElement &&    // alternative standard method
        !document.mozFullScreenElement && !document.webkitFullscreenElement);
      },
      onKeyDown:function(event)
	    {//overidable method stand in
	    },
      onKeyUp:function(event)
	    {//overidable method stand in
	    },
      onPointerMove:function(event)
      {
        if(!this.selectionHelper) return;

        var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this.highlightedObject = this.selectionHelper.getObjectAt(x,y);

        this._noMove = false;
      },
      onPointerDown:function(event)
      {
        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._noMove = true;
        this._actionInProgress = true;
        this._pushStart = new Date().getTime();

      },
      onPointerUp:function(event)
      {
        if(!this.selectionHelper) return;

        var event = event.impl || event;
        normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

        this._actionInProgress = false;
          var _pushEnd = new Date().getTime()
          var _elapsed = _pushEnd - this._pushStart;
          this._longAction = !(_elapsed <= 125);
          this._longStaticTap = (_elapsed >= 300 && this._noMove == true);

          var selected = this.selectionHelper.getObjectAt(x,y);

          if(this._longStaticTap)
          {
            this.fire("longstatictap",{position:{x:x,y:y}});
          }
          else if( selected != null && selected != undefined)
          {
            this.selectionHelper.selectObjectAt(x,y)
            this.selectedObject = selected
          }
          else
          {
            if (this._longAction == false)
            {
              this.selectedObject = null;
					    this.selectionHelper._unSelect();
            }
            else
            {
              this.fire("longmovetap",{position:{x:x,y:y}});
            }
          }
      },
      //public api
      toggleScene:function( name )
      {
        //TODO: cleanup
        console.log("scenes", this.scenes);
        var scene = this.scenes[name];
        if(scene) this.scene = scene; this.setupHelpers(); this.scene.add( this.camera);
      },
      clearScene:function()
      {
        while (this.hierarchyRoot.children.length > 0) {
          this.hierarchyRoot.remove(this.hierarchyRoot.children[this.hierarchyRoot.children.length - 1]);
        }
        // cleanup without calling render (data needs to be cleaned up before a new scene can be generated)
        //see here https://github.com/mrdoob/three.js/issues/2760
        if(this.renderer instanceof THREE.WebGLRenderer)
        {
          this.renderer.initWebGLObjects(this.scene);
        }
      },
	    addToScene: function ( object )
	    {
		    try
		    {
			    this.hierarchyRoot.add( object );
		    }
		    catch(error)
		    {
			    console.log("Failed to add object",object, "to scene: error", error)
		    }
	    },
      removeFromScene : function( object )
      {
        try
		    {
			    this.hierarchyRoot.remove( object );
		    }
		    catch(error)
		    {
			    console.log("Failed to remove object from scene: error", error)
		    }
      },
	    captureScreen:function(callback, width, height)
	    {
		    var width = width || 640;
		    var height = height || 480;
		    if(callback === undefined)
		    {
			    throw new Error("no callback provided");
		    }
		    captureScreen(callback, this.renderer.domElement, width, height);
	    },

      _injectScene: function(scene, active){

        if(!this.scenes) this.scenes = {};
        this.scenes[scene.name] = scene;

        if(active && scene !== this.scene)
        {
          if(this.scene) scene.children = this.scene.children;
          this.scene = scene;
          console.log("scene", scene.name,"is active")
        }
      },
      _injectCamera: function(camera){
        this.camera = camera;
          
        this.camera.aspect = this.width / this.height;
        this.camera.setSize(this.width,this.height);
		    this.camera.updateProjectionMatrix();

        console.log("camera", camera, this.width, this.height);
        console.log("camera is active")
      },
      _injectControls: function(controls){
        this.controls = controls;
        console.log("controls are active",controls)
      },

      add3: function(child) {
        console.log("In root element : child", child.localName,child.object)

        //TODO: do this MUCH better
        if( child.localName === 'three-js-scene'){
           var scene = child.object;
           var active = child.attributes.getNamedItem("active");
           this._injectScene(scene, active)
        }
        if (child.localName === 'three-js-camera' || child.localName === 'three-js-combinedcamera' ) {
          var camera = child.object;
          this._injectCamera(camera);
        }

        if( child.localName === 'three-js-orbitcontrols')
        {
          var controls = child.object;
          this.async(function()
          {
            child.init(this.camera,this.renderer);
            this._injectControls(controls);
          });
        }
        if( child.localName === 'three-effect-composer')
        {
          console.log("adding effect composer");
          this.finalComposer = child.composer;
          this.finalComposer.setSize(this.width, this.height);
        }
      },
      remove3: function(child) {
        this.scene.remove(child.object);
        this.invalidate();
      },
      getRenderer: function(event) {
        event.detail.renderer = this.renderer;
        console.log("here")
        //return this.renderer;
      },
      getScene: function(event) {
        event.detail.scene = this.scene;
        //return this.scene;
      },
      getCamera: function(event) {
        event.detail.camera = this.camera;
        //return this.scene;
      },
      //
      track: function(event) {
        //this.render();
        //this.controls.update();
        return;
        var obj = this.camera;
        var obj = this.querySelector('[tracking]').object;
        //console.log("tracking",obj)
        if (obj) {
          // TODO(sjmiles): accumulating derivatives is numerically unstable
          // integrating samples over a single track sequence is a better practice
          // make this easier to do properly
          obj.position.x += event.ddx;
          obj.position.z += event.ddy;
          this.render();
        }
      },
      //attribute change handlers / various handlers
      renderNowChanged: function() {
        this.render();
      },
      fullScreenChanged:function()
      {
        if(this.fullScreen)
        {
          if(this.requestFullScreen)this.requestFullScreen();
          if(this.webkitRequestFullScreen)this.webkitRequestFullScreen();
          if(this.mozRequestFullScreen)this.mozRequestFullScreen();
        }
        else
        {
          if(document.cancelFullScreen) document.cancelFullScreen();
          if(document.webkitCancelFullScreen) document.webkitCancelFullScreen();
          if(document.mozCancelFullScreen) document.mozCancelFullScreen();
        }
      },
      highlightedObjectChanged:function(oldHighlight)
      {
        console.log("highlighted object changed",this.highlightedObject);
      },
      selectedObjectChanged:function(oldSelection)
      {
         console.log("SELECTED object changed",this.selectedObject);
      },
      invalidate: function() {
        this.validateJob = this.job(this.validateJob, this.validate, 250);
      },
      validate: function() {
        (this.validateJob || this.nullJob).stop();

        if(this.controls) this.controls.update();
        this.render();
      },
      nullJob: {
        stop: function(){}
      },
      //other
      render: function() {
        if (! this.camera) {
          console.log('no camera');
          return;}
        if (this.renderer instanceof THREE.WebGLRenderer && this.postProcess == true && this.finalComposer)
        {
          //necessary hack for effectomposer
          THREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
          THREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
          THREE.EffectComposer.scene = new THREE.Scene();
          THREE.EffectComposer.scene.add( THREE.EffectComposer.quad );
          this.finalComposer.render();
        }
        else
        {
          this.renderer.render( this.scene, this.camera );
        }
      },
      animate: function() 
      {
	      this.render();		
	      this.update();
	      requestAnimationFrame(this.animate.bind(this))
      },
      update: function()
      {
	        if(this.controls) this.controls.update();
      },
      //utilities: TODO: move this to seperate js file
	    convertColor: function(hex)
	    {
        hex = parseInt("0x"+hex.split('#').pop(),16);
        return  hex;
	    },
      _setStyle:function()
      {
	      //setup width & height
	      var cs = window.getComputedStyle(this);
	      this.width = parseInt(cs.getPropertyValue("width").replace("px",""));
	      this.height = parseInt(cs.getPropertyValue("height").replace("px",""));
        //setup backround color
	      this.bg = cs.getPropertyValue("background-color");
      },
    });
  </script>
</polymer-element>

