<script src="lib/postProcessing/EffectComposer.js"></script>
<script src="lib/postProcessing/RenderPass.js"></script>
<script src="lib/postProcessing/ShaderPass.js"></script>
<script src="lib/postProcessing/MaskPass.js"></script>
<script src="lib/postProcessing/shaders/CopyShader.js"></script>

<polymer-element name="three-post-fx" attributes="name">
  <script>Polymer('three-post-fx',{
    name: "default",
    effect: null,
    enteredView:function()
    { 
      if(this.parentNode)
      {
          this.parentNode.addEffect(this.name, this.effect);
      }
    }
  });
  </script>
</polymer-element>

<script src="lib/postProcessing/shaders/VignetteShader.js"></script>

<polymer-element name="vignette-fx" extends="three-post-fx" attributes="offset darkness">
  <script>Polymer('vignette-fx',{
    name: 'vignette',
    effect: null,
    offset : 0.4,
    darkness: 5,
    observe: {
       offset: 'uniformsChanged',
       darkness: 'uniformsChanged'
    },
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.VignetteShader);
      this.effect.uniforms["offset"].value = this.offset;
      this.effect.uniforms["darkness"].value = this.darkness;
    },
    uniformsChanged:function()
    {
      this.effect.uniforms["offset"].value = this.offset;
      this.effect.uniforms["darkness"].value = this.darkness;
    }
  });
  </script>
</polymer-element>

<polymer-element name="brightness-fx" extends="three-post-fx">
  <script>Polymer('brightness-fx',{
    effect: null,
    amount: 0.5,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.BrigthnessShader);
      this.effect.uniforms["amount"].value = this.amount;
    }
  });
  </script>
</polymer-element>


<script src="lib/postProcessing/shaders/KaleidoShader.js"></script>

<polymer-element name="kaleido-fx" extends="three-post-fx">
  <script>Polymer('kaleido-fx',{
    name:'kaleido',
    effect: null,
    sides: 2.0,
    angle: 0.0,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.KaleidoShader); 
      this.effect.uniforms["sides"].value = this.sides;
      this.effect.uniforms["angle"].value = this.angle;
    }
  });
  </script>
</polymer-element>

<polymer-element name="sepia-fx" extends="three-post-fx">
  <script>Polymer('sepia-fx',{
    effect: null,
    amount: 6.0,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.SepiaShader);
      this.effect.uniforms["amount"].value = this.amount;
    }
  });
  </script>
</polymer-element>

<script src="lib/postProcessing/shaders/HueSaturationShader.js"></script>

<polymer-element name="hueSaturation-fx" extends="three-post-fx" attributes="hue saturation">
  <script>Polymer('hueSaturation-fx',{
    name:'hue-saturation',
    effect: null,
    hue: 0.0,
    saturation: 0.0,
    observe: {
       hue: 'uniformsChanged',
       saturation: 'uniformsChanged'
    },
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.HueSaturationShader);
      this.effect.uniforms["hue"].value = this.hue;
      this.effect.uniforms["saturation"].value = this.saturation;
    },
    uniformsChanged:function()
    {
      this.effect.uniforms["hue"].value = this.hue;
      this.effect.uniforms["saturation"].value = this.saturation;
    }
  });
  </script>


<polymer-element name="three-effect-composer" >
  <script>Polymer('three-effect-composer',{
    enabled: true,
    active:false,
    effects: [],
    resolutionBase : 1,
    resolutionMultiplier : 1.5,

    renderer: null,
    composer: null,

    enteredView:function()
    {
      console.log("effect composer entered view",this.hue);
      /*alt method to get scene
      var activeScene = document.querySelectorAll('three-js-scene[active]')[0];
      this.hierarchyRoot = activeScene.querySelector('[hierarchyRoot]').object;*/
      this.async(function() {
        var detail = this.fire('three-js-get-renderer', {}).detail;
        if (detail) {this.renderer = detail.renderer;}
        var detail = this.fire('three-js-get-scene', {}).detail;
        if (detail) {this.scene = detail.scene;}
        var detail = this.fire('three-js-get-camera', {}).detail;
        if (detail) {this.camera = detail.camera;}
        
        if(this.scene && this.renderer && this.camera)
        {
          //console.log("bla: renderer",this.renderer, "scene", this.scene);
          this._init();
          this.addToParent3();
        }
      });
    },
    //initialization methods
    _init:function()
    {
      //console.log("inititalizing effect composer");
      if(this.renderer instanceof THREE.WebGLRenderer && this.enabled)
      {
        //shaders, post processing etc, various passes and rtts
        var renderPass = new THREE.RenderPass(this.scene, this.camera);
        var copyPass = new THREE.ShaderPass( THREE.CopyShader );

        this.composer = new THREE.EffectComposer( this.renderer );

        //prepare the final render passes
        this.composer.addPass( renderPass );

        for(var i=0; i<this.effects.length;i++)
        {
            var effect = this.effects[i];
            this.composer.addPass( effect );
        }
        //make sure the last pass renders to screen
        this.composer.passes[this.composer.passes.length-1].renderToScreen = true;
        this.composer.__element = this;
      }
    },
    //attribute change handlers
    effectsChanged:function()
    {
      this.active = true = (this.effects.length>0)
    },
    //public api
    addEffect:function(name, effect)
    {
      this.effects.push( effect );
    },
    addToParent3: function() {
      if (this.parentNode.add3 && !this.objectParent) {
        this.objectParent = this.parentNode;
        this.parentNode.add3(this);
        var parentName = this.parentNode.localName;
        //console.log('[%s]: request adding to [%s]', this.localName + (this.id ? '#' + this.id : ''), parentName);
      }
    },
  });
  </script>
</polymer-element>
