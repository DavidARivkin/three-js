<script src="lib/postProcessing/EffectComposer.js"></script>
<script src="lib/postProcessing/RenderPass.js"></script>
<script src="lib/postProcessing/ShaderPass.js"></script>
<script src="lib/postProcessing/MaskPass.js"></script>
<script src="lib/postProcessing/shaders/CopyShader.js"></script>

<polymer-element name="three-post-fx" constructor="threeJsPostFx" attributes="name">
  <script>Polymer('three-post-fx',{
    name: "default",
    effect: null,
    enteredView:function()
    { 
      if(this.parentNode)
      {
          this.parentNode.addEffect(this);
      }
    }
  });
  </script>
</polymer-element>

<script src="lib/postProcessing/shaders/VignetteShader.js"></script>

<polymer-element name="vignette-fx" extends="three-post-fx" attributes="offset darkness">
  <script>Polymer('vignette-fx',{
    name: 'vignette',
    effect: null,
    offset : 0.4,
    darkness: 5,
    observe: {
       offset: 'uniformsChanged',
       darkness: 'uniformsChanged'
    },
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.VignetteShader);
      this.effect.uniforms["offset"].value = this.offset;
      this.effect.uniforms["darkness"].value = this.darkness;
    },
    uniformsChanged:function()
    {
      this.effect.uniforms["offset"].value = this.offset;
      this.effect.uniforms["darkness"].value = this.darkness;
    }
  });
  </script>
</polymer-element>

<polymer-element name="brightness-fx" extends="three-post-fx">
  <script>Polymer('brightness-fx',{
    effect: null,
    amount: 0.5,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.BrigthnessShader);
      this.effect.uniforms["amount"].value = this.amount;
    }
  });
  </script>
</polymer-element>


<script src="lib/postProcessing/shaders/KaleidoShader.js"></script>

<polymer-element name="kaleido-fx" extends="three-post-fx">
  <script>Polymer('kaleido-fx',{
    name:'kaleido',
    effect: null,
    sides: 2.0,
    angle: 0.0,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.KaleidoShader); 
      this.effect.uniforms["sides"].value = this.sides;
      this.effect.uniforms["angle"].value = this.angle;
    }
  });
  </script>
</polymer-element>

<polymer-element name="sepia-fx" extends="three-post-fx">
  <script>Polymer('sepia-fx',{
    effect: null,
    amount: 6.0,
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.SepiaShader);
      this.effect.uniforms["amount"].value = this.amount;
    }
  });
  </script>
</polymer-element>

<script src="lib/postProcessing/shaders/HueSaturationShader.js"></script>

<polymer-element name="hueSaturation-fx" extends="three-post-fx" attributes="hue saturation">
  <script>Polymer('hueSaturation-fx',{
    name:'hue-saturation',
    effect: null,
    hue: 0.0,
    saturation: 0.0,
    observe: {
       hue: 'uniformsChanged',
       saturation: 'uniformsChanged'
    },
    ready: function()
    {
      this.effect = new THREE.ShaderPass(THREE.HueSaturationShader);
      this.effect.uniforms["hue"].value = this.hue;
      this.effect.uniforms["saturation"].value = this.saturation;
    },
    uniformsChanged:function()
    {
      this.effect.uniforms["hue"].value = this.hue;
      this.effect.uniforms["saturation"].value = this.saturation;
    }
  });
  </script>


<polymer-element name="three-effect-composer" constructor="threeJsFxComposer" attributes="name renderTarget2 toScreen ignore output input">
  <script>Polymer('three-effect-composer',{
    name : "",
    enabled: true,
    active: false,
    
    effects: null,
    resolutionBase : 1,
    resolutionMultiplier : 1.5,
    width: window.innerWidth || 1,
    height: height = window.innerHeight || 1,

    renderer: null,
    composer: null,
    target: null,
    renderTarget2:null,
    renderOutput:null,
    
    toScreen:true,
    
    ignore:[],//list of scene names to ignore
    output:"diffuse", //can be either diffuse, normal, depth

    created:function()
    {
      this.effects = [];
      
      this.viewports = {};
    },
    enteredView:function()
    {
      //console.log("effect composer entered view");
      /*alt method to get scene
      var activeScene = document.querySelectorAll('three-js-scene[active]')[0];
      this.hierarchyRoot = activeScene.querySelector('[hierarchyRoot]').object;*/
      this.async(function() {
        var detail = this.fire('three-js-get-renderer', {}).detail;
        if (detail) {this.renderer = detail.renderer;}
        var detail = this.fire('three-js-get-scene', {}).detail;
        if (detail) {this.scene = detail.scene;this.activeScenes = detail.activeScenes}
        var detail = this.fire('three-js-get-camera', {}).detail;
        if (detail) {this.camera = detail.camera;}
        /*if(this.scene && this.renderer && this.camera)
        {*/
          this._init();
          console.log("foo");
          this.addToParent3();
        //}
      });
      window.addEventListener('resize',this.onResize.bind(this));
    },
    onResize:function(event)
    {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      //this.renderTarget.width = this.width;
      //this.renderTarget.height = this.height;
      this.dpr = 1;
      this.resUpscaler=1;
      this.hRes = this.width * this.dpr * this.resUpscaler;
      this.vRes = this.height * this.dpr * this.resUpscaler;
      this.composer.setSize(this.hRes, this.vRes);
    },
    
    //initialization methods
    //FIXME: just for testing, needs refactoring
    
    altInit:function(renderer, activeScenes, camera)
    {
    
      this.renderer = renderer;
      this.activeScenes = activeScenes;
      this.camera = camera;
      this._simpleInit();
      /*var detail = this.fire('three-js-get-renderer', {}).detail;
        if (detail) {this.renderer = detail.renderer;}
        var detail = this.fire('three-js-get-scene', {}).detail;
        if (detail) {this.scene = detail.scene;this.activeScenes = detail.activeScenes}
        var detail = this.fire('three-js-get-camera', {}).detail;
        if (detail) {this.camera = detail.camera;}*/
    },
    _simpleInit:function()
    {
      console.log("ignoring",this.ignore);
      //shaders, post processing etc, various passes and rtts
      this.composer = new THREE.EffectComposer( this.renderer );
      
      var viewports = this.parentNode.querySelectorAll("three-js-viewport");
      console.log("viewports", viewports);

      //prepare the final render passes
      //add a simple render pass first
      for(var key in this.activeScenes)
      {
        var activeScene = this.activeScenes[key];
        if(this.ignore.indexOf(key)==-1)
        {
          var renderPass = new THREE.RenderPass(activeScene, this.camera);//, null, false, false);  
          renderPass.clear = false;
          this.composer.addPass( renderPass );    
        }
      }
      if(this.composer.passes.length>0) this.composer.passes[0].clear = true;

      //do all post process 
      for(var i=0; i<this.effects.length;i++)
      {
          var effectElement = this.effects[i];
          //if(effectElement.init) effectElement.init(this.renderer, this.scene, this.camera);
          var pass = effectElement.effect;
          this.composer.addPass( pass );
      }
      //if(this.composer.passes.length>1) this.composer.passes[this.composer.passes.length-1].clear = false;
      
      //now render scenes with no post processing
      for(var key in this.activeScenes)
      {
        var activeScene = this.activeScenes[key];
        if(this.ignore.indexOf(key)>-1)
        {
          var renderPass = new THREE.RenderPass(activeScene, this.camera, null, false, false);  
          //HACK !!
          renderPass.clear = false;
          this.composer.addPass( renderPass );    
        }
      }
      var lastPass = this.composer.passes[this.composer.passes.length-1];
      lastPass.clearAlpha= false;
      lastPass.clear = false;
      //lastPass.clearColor= false;
      //lastPass.needsSwap = true;

      var copyPass = new THREE.ShaderPass( THREE.CopyShader );
      this.composer.addPass( copyPass );
      
      if(this.toScreen)
      {
        //make sure the last pass renders to screen
        this.composer.passes[this.composer.passes.length-1].renderToScreen = true;
      }
      console.log(this.name + " effects",this.composer.passes);
    },
    _fullInit:function()
    {
      //shaders, post processing etc, various passes and rtts
        var renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
        this.renderTarget = new THREE.WebGLRenderTarget( this.width, this.height, renderTargetParameters );
        this.composer = new THREE.EffectComposer( this.renderer, this.renderTarget );
        //prepare the final render passes
        
        for(var i=0; i<this.effects.length;i++)
        {
          var effectElement = this.effects[i];
          if(effectElement.init) effectElement.init(this.renderer, this.scene, this.camera);
          
          var effect = effectElement.effect;
          this.composer.addPass( effect );
        }
        console.log(this.name + " effects",this.composer.passes);
        
        //make sure the last pass renders to screen
        if(this.toScreen)
        {
          this.composer.passes[this.composer.passes.length-1].renderToScreen = true;
        }
        this.composer.__element = this;
        this.renderTarget2 = this.composer.renderTarget2;
        
        this.composer.subComposers = [];
    },
    
    
    _init:function()
    {
      if(this.renderer instanceof THREE.WebGLRenderer && this.enabled)
      {
        this._simpleInit();
      }
    },
    //attribute change handlers
    effectsChanged:function()
    {
      this.active = (this.effects.length>0);
    },
    //internal methods
    render:function()
    {
      this.composer.render();
    },
    //public api
    addEffect:function(effect)
    {
      this.effects.push( effect );
    },
    add3:function ( child )
    {
      if( child.localName === 'three-effect-composer')
      {
        this.composer.subComposers.push( child.composer );
        //FIXME:hack
        this.renderTarget2 = this.composer.renderTarget2;
      }
    },
    addToParent3: function() {
      if (this.parentNode.add3 && !this.objectParent) {
        this.objectParent = this.parentNode;
        this.parentNode.add3(this);
        var parentName = this.parentNode.localName;
        //console.log('[%s]: request adding to [%s]', this.localName + (this.id ? '#' + this.id : ''), parentName);
      }
    },
  });
  </script>
</polymer-element>
